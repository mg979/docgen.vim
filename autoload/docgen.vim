" VARIABLES {{{1

let s:supported = ['vim', 'lua', 'python', 'sh', 'java', 'ruby', 'go', 'c', 'cpp']

let s:ph = '$' . 'PLACEHOLDER'

" }}}


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Main functions
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""


""
" docgen#box: create a comment box, or convert an existing comment to a box
" @param bang: with full length frame
" @param cnt:  extra height of the box, both above and below
""
fun! docgen#box(bang, count) abort
  " {{{1
  let doc = s:new(0)

  " evaluate and apply docstring style
  let doc.style.is_boxed = a:bang
  if a:count
    call doc.style.change(a:count - 1)
    call doc.style.apply()
    call doc.style.echo()
  else
    call doc.style.apply()
  endif

  let doc.was_comment = doc.is_comment(line('.'))
  let lines = doc.create_box(doc.replace_comment(), doc.comment()[3])
  exe 'silent' (doc.was_comment ? '-1': '') . 'put =lines'

  call doc.reindent_box(lines)
  normal! `[
  exe 'normal!' (doc.style.extraHeight + 1) . 'j'
  " could be a converted comment
  let @= = doc.was_comment ? '""' : '"A "'
endfun "}}}


""
" docgen#func: create or update template for function documentation
" @param bang: with full length frame
" @param count: set style
""
fun! docgen#func(bang, count) abort
  " {{{1
  let [ft, @=] = [split(&filetype, '\.')[0], '""']
  if index(s:supported, ft) < 0 && !exists('b:docgen')
    echo '[docgen] not supported'
    return
  endif

  let doc = s:new(1)

  " with bang, we only change the current style, we don't parse anything
  if a:bang
    if a:count
      call doc.style.change(a:count - 1)
    else
      call doc.style.change_below()
    endif
    call doc.style.echo()
    return
  endif

  " evaluate and apply docstring style
  if a:count
    call doc.style.change(a:count - 1)
    call doc.style.apply()
    call doc.style.echo()
  else
    call doc.style.apply()
  endif

  if ft == 'cpp'
    call doxygen#comment_func(doc)
    return
  endif

  " if the parsers can't find a target, abort
  let startLn = doc.parse()
  if !startLn | return | endif

  " generate templates for docstring lines
  call doc.make_templates()

  " move to the line with the function declaration
  exe startLn

  " get the formatted lines
  let lines = doc.format()

  " keep the old lines of the previous docstring, if unchanged
  let lines = doc.preserve_oldlines( lines, doc.previous_docstring(startLn, doc.below()) )

  " align placeholders and create box
  let lines = doc.create_box( lines, doc.frameChar() )

  exe 'silent ' ( doc.below() ? '' : '-1' ) . 'put =lines'
  call doc.reindent_box(lines)

  " edit first placeholder, or go back to starting line if none is found
  normal! {
  if search(s:ph, '', startLn + len(lines))
    let @/ = s:ph
    let @= = '''"_cgn'''
  else
    let @= = '""'
    exe startLn
  endif
endfun "}}}



"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Docstring formatter initializer
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

""
" The docstring is generated in several passages:
"
" 1. the parsers for the filetype are generated.
" 2. the parsers look for a potential target, if nothing is found the process
"     is aborted.
" 3. the style settings are evaluated, and raw (unformatted) templates for
"     lines are generated.
" 4. the target is parsed and a list of matches is the generated.
" 5. these matches are fed to the raw lines, that are formatted with printf()
"     using the matches as arguments.
"
" @member parsed:     parsed elements of the docstring (name, params, type, rtype)
"                     -> generated by doc.parse()
" @member templates:  unformatted templates for lines (header, params, rtype)
"                     -> generated by doc.templates()
" @member lines:      the formatted lines as they will be pasted in the buffer
"                     -> generated by doc.format()
""
let s:Doc = { 'parsed': {}, 'templates': {}, 'lines': {} }


""
" s:new: start a new DocGen instance
" @return: the instance
""
fun! s:new(is_docstring) abort
  "{{{1
  " b:docgen can create a new s:{&filetype} variable, to add support for
  " unsupported filetypes
  if exists('b:docgen')
    let s:{&filetype} = extend(get(s:, &filetype, {}), b:docgen)
  endif

  let doc = extend(deepcopy(s:Doc), s:FT())
  let doc.style = s:Style
  let doc.style.is_docstring = a:is_docstring
  " so that s:Style can access the current instance
  let doc.style.doc = doc
  return doc
endfun "}}}




"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Docstring formatter patterns
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" default formatters for docstring lines
let s:Doc.headerFmt   = { -> {
      \ 'boxed':    ['Function: %s' . s:ph, ''],
      \ 'default':  ['Function: %s' . s:ph, ''],
      \ 'simple':   ['%s:' . s:ph],
      \ 'minimal':  ['%s:' . s:ph, ''],
      \} }

fun! s:Doc.paramsFmt()
  " {{{1
  return [self.jollyChar() . 'param %s: ' . s:ph]
endfun "}}}

fun! s:Doc.rtypeFmt()
  " {{{1
  return [self.jollyChar() . 'return: ' . s:ph]
endfun "}}}

" default patterns for function name, parameters, pre and post
let s:Doc.typePat   = { -> '\(\)' }
let s:Doc.namePat   = { -> '\s*\([^( \t]\+\)' }
let s:Doc.paramsPat = { -> '\s*(\(.\{-}\))' }
let s:Doc.rtypePat  = { -> '\s*\(.*\)\?' }

" default order for patterns, and the group they match in matchlist()
let s:Doc.order     = { -> ['type', 'name', 'params', 'rtype'] }

" default sections of the docstring
let s:Doc.sections  = { -> ['header', 'params', 'rtype'] }


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Docstring formatter styles
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let s:Doc.boxed     = { -> 0 }
let s:Doc.minimal   = { -> 0 }
let s:Doc.putBelow  = { -> 0 }
let s:Doc.jollyChar = { -> '@' }

fun! s:Doc.frameChar()
  "{{{1
  return self.comment()[3]
endfun "}}}

fun! s:Doc.boxed()
  " {{{1
  return self.style.get_style() =~ 'box'
endfun "}}}

fun! s:Doc.minimal()
  " {{{1
  return self.style.get_style() == 'minimal'
endfun "}}}

fun! s:Doc.below()
  " {{{1
  return get(s:FT(), '_putBelow', self.putBelow())
endfun "}}}




"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Docstring parser
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

""
" Function: s:Doc.parse
" Parse the function declaration and get its name, parameters and return type.
"
" The parser creates a list of matches based on the different subpatterns.
" These subpatterns have a specific order, depending on the filetype.
" Once the list of matches is created, the groups must be assigned to the right
" variable in the right order, that is given by doc.order().
" For example, if 'type' comes first in the order, parsed.type will be the
" variable that is assigned to the first matched group.
"
" Which variable will be assigned to which group, depends doc.order().
"
" @return: the line number with the function declaration
""
fun! s:Doc.parse() abort
  "{{{1
  let [self.startLn, self.endLn] = self.search_target()
  if !self.startLn
    return 0
  endif
  let all  = matchlist(join(getline(self.startLn, self.endLn), "\n"), self.pattern)[1:]
  let ix = 0
  for group in self.order()
    let self.parsed[group] = trim(all[ix])
    let ix += 1
  endfor
  return self.startLn
endfun "}}}


""
" Function: s:Doc.search_target
" Search the closest target upwards, if it can be found set the current pattern
" to the one that found it.
"
" @return: the line number with the docstring target
""
fun! s:Doc.search_target() abort
  "{{{1
  let [startLn, endLn] = [0, 0]
  let emptyLn = search('^\s*$', 'cnbW')
  let minLn = emptyLn ? '\%>' . emptyLn . 'l' : ''
  for p in self.make_parsers()
    if !startLn || search(minLn . p, 'cnbW') > startLn
      let startLn = search(minLn . p, 'cnbW')
      let endLn = search(minLn . p, 'cnbeW')
      if !endLn || endLn < startLn
        let endLn = search(minLn . p, 'cneW')
      endif
      let self.pattern = p
    endif
  endfor
  return [startLn, endLn]
endfun "}}}


""
" Function: s:Doc.make_parsers
" Format the parsers with printf(), replacing the placeholders with the
" specific patterns for the current filetype.
"
" @return: the formatted parsers
""
fun! s:Doc.make_parsers() abort
  "{{{1
  let d = self
  let parsers = []
  let u_parsers = d.parsers()
  let pats = join(map(self.ordered_patterns(), { k,v -> string(v) }), ',')
  for p in range(len(u_parsers))
    let P = eval('printf(u_parsers[p],' . pats .')')
    call add(parsers, P)
  endfor
  return parsers
endfun "}}}


""
" Function: s:Doc.ordered_patterns
"
" @return: the patterns of the parser, in the order defined by the filetype
""
fun! s:Doc.ordered_patterns() abort
  "{{{1
  let s = self
  let o = self.order()
  return map(o, { k,v -> eval('s.'.o[k].'Pat()') })
endfun "}}}



"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Docstring templates
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

fun! s:Doc.make_templates() abort
  let style = self.style.get_style()
  for x in self.sections()
    let fmt = eval('self.'.x.'Fmt()')
    let self.templates[x] = type(fmt) == v:t_dict ? fmt[style] : fmt
  endfor
endfun



"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Docstring formatting
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

fun! s:Doc.format() abort
  " process params and return first, if absent the docstring will be reduced
  let self.lines.params = self.paramsLines()
  let self.lines.return = self.retLines()
  let self.lines.header = self.headerLines()
  return self.lines.header + s:align(self.lines.params) + self.lines.return
endfun

""
" Function: s:Doc.headerLines
"
" @return: the line(s) with the formatted description
""
fun! s:Doc.headerLines() abort
  "{{{1
  let header = self.templates.header

  " some text that doesn't contain %s placeholders, return it as it is
  let linesWithName = filter(copy(header), 'v:val =~ "%s"')
  if empty(linesWithName)
    return header
  endif

  " remove empty lines if no params nor return statement
  if empty(self.lines.params) && empty(self.lines.return)
    call filter(header, { k,v -> v != '' })
  endif

  return map(header, { k,v -> v =~ '%s' ? printf(v, self.parsed.name) : v })
endfun "}}}


""
" Function: s:Doc.paramsNames
" Parse the parameters string, remove unwanted parts, and return a list with
" the parameters names.
"
" @return: a list with the parameters names
""
fun! s:Doc.paramsNames() abort
  "{{{1
  let params = substitute(self.parsed.params, '<.\{-}>', '', 'g')
  let params = substitute(params, '\s*=\s*[^,]\+', '', 'g')
  return split(params, ',')
endfun "}}}


""
" Function: s:Doc.paramsLines
"
" @return: the formatted line(s) with parameters
""
fun! s:Doc.paramsLines() abort
  "{{{1
  if empty(self.templates.params) || self.minimal()
    return []
  endif
  let lines = []
  for param in self.paramsNames()
    for line in self.templates.params
      call add(lines, line =~ '%s' ? printf(line, trim(param)) : line)
    endfor
  endfor
  return lines
endfun "}}}


""
" Function: s:Doc.retLines
" By default there's no text replacement in the return line, so the template is
" returned as it it.
"
" @return: the formatted line(s) with the return value
""
fun! s:Doc.retLines() abort
  "{{{1
  return self.minimal() ? [] : self.templates.rtype
endfun "}}}


""
" Function: s:Doc.comment
"
" @return: a list with four elements:
"          [0]  the opening multiline comment chars
"          [1]  the chars for lines in between
"          [2]  the closing multiline comment chars
"          [3]  a single char used for box frame
""
fun! s:Doc.comment()
  " {{{1
  let cm = &commentstring =~ '//\s*%s' ? '/*%s*/' : &commentstring
  let c = substitute(split(&commentstring, '%s')[0], '\s*$', '', '')
  return cm == '/*%s*/' ? ['/*', ' *', ' */', '*'] : [c, c, c, trim(c)[:0]]
endfun "}}}


""
" Function: s:Doc.preserve_oldlines
" Keep the valid lines of the previous docstring
"
" @param lines:    the new lines
" @param oldlines: the old lines
" @return: the merged lines
""
fun! s:Doc.preserve_oldlines(lines, oldlines) abort
  " {{{1
  " here we handle docstring generated lines, not extra edits
  " we compare the generated lines with the old lines, and we keep the ones
  " that look similar
  for l in range(len(a:lines))
    let line = substitute(a:lines[l], '\V' . s:ph, '', 'g')
    for ol in a:oldlines
      if line != '' && ol =~ '^\V' . trim(line)
        let a:lines[l] = ol
        break
      endif
    endfor
  endfor
  " here we handle extra edits, that is lines that have been inserted by the
  " user and that are not part of the generated docstring
  for o in range(len(a:oldlines))
    let ol = a:oldlines[o]
    " if the old line looks like @param, @rtype, etc, it's been generated and
    " we've already handled it
    if ol =~ s:docstring_words(['param', 'return', 'rtype'])
      continue
    endif
    if index(a:lines, ol) < 0
      call insert(a:lines, ol, o)
    endif
  endfor
  return a:lines
endfun "}}}


""
" Function: s:Doc.previous_docstring
"
" @param start: start line
" @param below: whether the docstring will be added below the declaration
" @return: the lines in the docstring before update
""
fun! s:Doc.previous_docstring(start, below) abort
  " {{{1
  let lines = []
  let start = a:start
  if !a:below
    while 1
      if start == 1
        break
      elseif self.is_comment(start - 1)
        call add(lines, getline(start - 1))
        exe (start - 1) . 'd _'
        let start -= 1
      else
        break
      endif
    endwhile
  else
    while 1
      if start == line('$')
        break
      elseif self.is_comment(start + 1)
        call add(lines, getline(start + 1))
        exe (start + 1) . 'd _'
        let start += 1
      else
        break
      endif
    endwhile
  endif
  let c = self.comment()[1]
  call map(lines, 'substitute(v:val, "^\\V" . c . " ", "", "")')
  return reverse(filter(lines, 'v:val =~ "\\k"'))
endfun "}}}


""
" Function: s:Doc.create_box
" Create a box with the docstring
"
" @param lines: the docstring lines
" @param boxed: with full frame or not
" @param rchar: character used for full frame
" @param extraHeight: additional empty lines near the edges
" @return: the box lines
""
fun! s:Doc.create_box(lines, char) abort
  " {{{1
  let [a, m, b, _] = self.comment()
  let rwidth = &tw ? &tw : 79
  if self.boxed() && a != b
    let box1 = a . repeat(a:char, rwidth - strlen(a))
    let box2 = ' ' . repeat(a:char, rwidth - strlen(a) - 1) . trim(b)
  elseif self.boxed()
    let box1 = m . repeat(a:char, rwidth - strlen(a))
    let box2 = box1
  else
    let box1 = a . trim(m)
    let box2 = m . trim(b)
  endif
  let extra = map(range(self.style.extraHeight), { k,v -> m })
  ""
  " Reformat the lines as comment. Top and bottom lines are not handled here.
  "   - empty line ? comment char(s)
  "   - no comment char(s) (eg. python docstrings)? just the line
  "   - both? concatenate comment chars and line, with a space in between
  ""
  call map(a:lines, 'v:val == "" ? m : m == "" ? v:val : (m . " " . v:val)')
  return [box1] + extra + a:lines + extra + [box2]
endfun "}}}


""
" Function: s:Doc.reindent_box
"
" @param lines: the lines to reindent
""
fun! s:Doc.reindent_box(lines) abort
  "{{{1
  silent keepjumps normal! `[=`]
  let ind = matchstr(getline('.'), '^\s*')
  let lines = map(a:lines, "substitute(v:val, '^\s*', ind, '')")
  let [first, i, char] = [line('.') + 1, line('.'), self.frameChar()]
  let maxw = &tw ? &tw : 79
  " executing DocBox on a previous comment and wanting a full box
  let is_boxifying_comment = !self.style.is_docstring &&
        \                     self.was_comment && self.style.fullbox

  for line in lines
    if strwidth(line) > maxw
      let removeChars = printf('\V%s\{%s}', char, strlen(line) - maxw)
      let line = substitute(line, removeChars, '', '')
    endif
    if is_boxifying_comment && strwidth(line) < maxw
      let line .= repeat(' ', maxw - strwidth(line) - strwidth(char)) . char
      if self.style.centered && i == first
        let ind = matchstr(line, '^\s*')
        let text = trim(matchstr(line, '^\V\s\*' . char . '\zs\.\*\ze' . char))
        let spaces = maxw - strlen(ind) - strwidth(text) - strwidth(char) * 2
        let s = repeat(' ', spaces/2)
        let [s1, s2] = spaces % 2 ? [s, s . ' '] : [s, s]
        let line = ind . char . s1 . text . s2 . char
      endif
    endif
    call setline(i, line)
    let i += 1
  endfor
endfun "}}}


""
" Function: s:Doc.is_comment
"
" @param line: the line to evaluate
" @return: if the evaluated line is a comment (or a docstring)
""
fun! s:Doc.is_comment(line) abort
  "{{{1
  return synIDattr(synID(a:line, indent(a:line) + 1, 1), "name") =~? 'comment'
endfun "}}}


""
" Function: s:Doc.replace_comment
" Replace previous docstring with the new one.
"
" @return: the removed lines, if not empty
""
fun! s:Doc.replace_comment() abort
  "{{{1
  let startLn = 0
  if self.is_comment(line('.'))
    let [startLn, endLn] = [line('.'), line('.')]
    while self.is_comment(startLn - 1)
      let startLn -= 1
    endwhile
    while self.is_comment(endLn + 1)
      let endLn += 1
    endwhile
    let lines = getline(startLn, endLn)
    " strip the previous comment chars
    call map(lines, { k,v -> substitute(v, '^\s*[[:punct:]]\+\s*', '', '') })
    if empty(lines[0])
      call remove(lines, 0)
    endif
    if empty(lines[-1])
      call remove(lines, -1)
    endif
    exe startLn . ',' . endLn . 'd _'
  else
    let lines = ['']
  endif
  return lines
endfun "}}}



"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Styles
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""
" this class is linked inside the Doc instance (doc.style)
""

let s:Style = {
      \  'docstring': ['default', 'boxed', 'simple', 'minimal'],
      \  'box': ['simple', 'box', 'large_simple', 'large_box', 'fullbox', 'fullbox_centered'],
      \}

""
" s:Style.change
" @param ...: change style to given index
""
fun! s:Style.change(...) abort
  "{{{1
  let ft = s:FT()
  let v = self.is_docstring ? 'dg_current' : 'db_current'
  if a:0
    let ft[v] = a:1 - 1
  else
    let ft[v] = self.get_current()
  endif
  if ft[v] >= len(self.get_list()) - 1
    let ft[v] = 0
  else
    let ft[v] += 1
  endif
endfun "}}}

""
" s:Style.change_below
"
" Toggle the variable that controls whether the docstring is added below or
" above the target. We set a filetype variable, so that this setting persits
" only for files of the same type.
""
fun! s:Style.change_below() abort
  "{{{1
  let ft = s:FT()
  let ft._putBelow = !self.doc.below()
endfun "}}}

""
" s:Style.apply
"
" Apply current style, generating templates for lines, and make it persistent
" for filetype.
""
fun! s:Style.apply() abort
  "{{{1
  let style = self.get_style()
  if self.is_docstring
    let self.extraHeight = 0
    let self.centered = 0
    let self.fullbox = 0
  else
    let self.extraHeight = style == 'large_simple' || style == 'large_box'
    let self.centered = style == 'fullbox_centered'
    let self.fullbox = style =~ 'fullbox'
  endif
endfun "}}}

""
" s:Style.echo: echo current style settings in the command line
""
fun! s:Style.echo() abort
  "{{{1
  let box = self.is_docstring ? '[docgen]' : '[docbox]'
  let blw = self.is_docstring && self.doc.below() ? '[below]' : ''
  echo box 'current style:' self.get_style() blw
endfun "}}}

""
" s:Style.get_style: currently active style for filetype
""
fun! s:Style.get_style() abort
  "{{{1
  return self.get_list()[self.get_current()]
endfun "}}}

""
" s:Style.get_current: current index in the styles list
""
fun! s:Style.get_current() abort
  "{{{1
  return self.is_docstring ? get(s:FT(), 'dg_current', 0)
        \                  : get(s:FT(), 'db_current', 0)
endfun "}}}

""
" s:Style.get_list: currently active styles list
""
fun! s:Style.get_list() abort
  "{{{1
  return self.is_docstring ? get(s:FT(), 'docstring_styles', self.docstring) :
        \self.is_boxed     ? filter(copy(get(s:FT(), 'box_styles', self.box)), { k,v -> v =~ 'box' })
        \                  : filter(copy(get(s:FT(), 'box_styles', self.box)), { k,v -> v !~ 'box' })
endfun "}}}




"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Filetype-specific
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

""
" Each filetype will define at least a list of function parsers.
" After that, each can provide specific members or methods.
""

let s:c = {
      \ 'parsers':   { -> ['^%s%s\n\?%s%s\s*\n\?[{;]'] },
      \ 'namePat':   { -> '\s*\(\w\+\|\*\?(\*?(\w\+)\)' },
      \ 'paramsPat': { -> '\s*(\(.\{-}\))' },
      \ 'typePat':   { -> '\(\%(extern\|static\|inline\)\s*\)*' },
      \ 'rtypePat':  { -> '\s*\(.\{-}\)' },
      \ 'order':     { -> ['type', 'rtype', 'name', 'params'] },
      \}

"{{{1
""
" This may be used as example to make a custom parser. EVERYTHING must be
" defined as a function (also lambda is ok). Whatever is not defined here, will
" have its fallback in the s:Doc class.
"
" The dictionary above contains the mandatory 'parsers' list.
" The xxxPat are the patterns that will replace the '%s' in the parsers,
" according to the order defined by the 'order' key.
"
" Then you can replace other methods.
"
" Functions with xxxFmt() are called first, when the style is applied. For
" maximum flexibility, they should return a dictionary with the available
" styles as keys, and the desired format as value. Sometimes you may just want
" to return nothing (that is an empty list).
"
" paramsNames() is called after the parameters have been parsed. It is used to
" refine how the parameters will be displayed, removing unwanted parts that
" have been parsed.
"
" Functions with xxxLines() are called last, and return the lines as they will
" be printed.
""
fun! s:c.rtypeFmt() abort
  if self.parsed.rtype == 'void'
    return []
  endif
  return {
      \ 'boxed':    ['', 'Returns ' . self.parsed.rtype . ': ' . s:ph],
      \ 'default':  ['', 'Returns ' . self.parsed.rtype . ': ' . s:ph],
      \ 'simple':   ['', 'Returns: ' . s:ph],
      \ 'minimal':  [],
      \}
endfun

fun! s:c.paramsFmt() abort
  return {
        \ 'boxed':    [self.jollyChar() . 'param %s: ' . s:ph],
        \ 'default':  [self.jollyChar() . 'param %s: ' . s:ph],
        \ 'simple':   ['%s: ' . s:ph],
        \ 'minimal':  [],
        \}
endfun

fun! s:c.headerFmt()
  return {
      \ 'boxed':    ['%s', s:ph],
      \ 'default':  ['%s', s:ph],
      \ 'simple':   ['%s', s:ph],
      \ 'minimal':  ['%s:' . s:ph],
      \}
endfun

fun! s:c.paramsNames() abort
  if self.parsed.params == 'void'
    return []
  endif
  return map(split(self.parsed.params, ','), { k,v -> substitute(split(v)[-1], '^\*', '', '') })
endfun

fun! s:c.headerLines() abort
  let header = self.templates.header
  if empty(self.lines.params) && empty(self.lines.return)
    return [ self.parsed.name . ':' . s:ph ]
  endif
  return map(header, { k,v -> v =~ '%s' ? printf(v, self.parsed.name) : v })
endfun "}}}

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let s:cpp = {}

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let s:vim = {
      \ 'parsers':   { -> ['^fu\k*!\?\s%s%s%s%s'] },
      \}

"{{{1
fun! s:vim.frameChar() abort
  return self.style.is_docstring ? '=' : '"'
endfun

""
" don't add the @return line if no meaningful return value
""
fun! s:vim.retLines() abort
  return self.minimal() ? [] :
        \ search('return\s*[[:alnum:]_([{''"]', 'nW', search('^endf', 'nW'))
        \ ? self.templates.rtype : []
endfun "}}}

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let s:lua = {
      \ 'parsers': { -> ['^%sfunction\s%s%s%s', '^%s%s\s*=\s*function%s%s'] },
      \ 'typePat': { -> '\(local\)\?\s*' },
      \}

"{{{1
fun! s:lua.headerLines() abort
  let style   = self.style.get_style()
  let oneline = empty(self.lines.params) && empty(self.lines.return)

  return style == 'minimal' || style == 'simple' || oneline
        \ ? [self.parsed.name . s:ph]
        \ : map(self.templates.header, { k,v -> v =~ '%s' ? printf(v, self.parsed.name) : v })
endfun

""
" don't add the @return line if no meaningful return value
""
fun! s:lua.retLines() abort
  return self.minimal() ? [] :
        \ search('return\s*[[:alnum:]_([{''"]', 'nW', search('^end', 'nW'))
        \ ? self.templates.rtype : []
endfun "}}}

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let s:python = {
      \ 'parsers':   { -> ['^\s*%s%s%s%s:'] },
      \ 'typePat':   { -> '\(class\|def\)\s*' },
      \ 'putBelow':  { -> 1 },
      \ 'jollyChar': { -> ':' },
      \}

"{{{1
fun! s:python.rtypeFmt() abort
  let rtype = substitute(self.parsed.rtype, '\s*->\s*', '', '')
  let rtype = empty(rtype) ? '' : '[' . trim(rtype) . ']'
  return [self.jollyChar() . 'return: ' . rtype . ' ' . s:ph]
endfun

fun! s:python.comment() abort
  return self.style.is_docstring ? ['"""', '', '"""', '"'] : ['#', '#', '#', '#']
endfun

fun! s:python.is_comment(line) abort
  return synIDattr(synID(a:line, indent(a:line) + 1, 1), "name") =~? 'comment\>\|string\>'
endfun

fun! s:python.paramsNames() abort
  let params = substitute(self.parsed.params, '\s*=\s*[^,]\+', '', 'g')
  while params =~ '('
    let params = substitute(params, '([^(]\{-})', '', 'g')
  endwhile
  while params =~ '\['
    let params = substitute(params, '\[[^[]\{-}]', '', 'g')
  endwhile
  while params =~ '{'
    let params = substitute(params, '{[^{]\{-}}', '', 'g')
  endwhile
  let params = substitute(params, ':[^,]\+', '', 'g')
  return split(params, ',')
endfun "}}}

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let s:sh = {
      \ 'parsers': { -> ['^function\s%s%s%s%s', '^%s%s%s%s'] },
      \}

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let s:java = {
      \ 'parsers':  { -> ['^\s*%s%s%s%s\s*[;{]'] },
      \ 'typePat':  { -> '\(\%(public\|private\|protected\|static\|final\)\s*\)*' },
      \ 'rtypePat': { -> '\s*\(\S\+\)\s\+' },
      \ 'order':    { -> ['type', 'rtype', 'name', 'params'] },
      \}

"{{{1

fun! s:java.rtypeFmt() abort
  if self.parsed.rtype == 'void'
    return []
  elseif self.parsed.rtype !~ '\S'
    return [self.jollyChar() . 'return: ' . s:ph]
  else
    let rtype = substitute(self.parsed.rtype, '<.*>', '', '')
    return [self.jollyChar() . 'return ' . rtype . ': ' . s:ph]
  endif
endfun

"}}}

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let s:ruby = {
      \ 'parsers': { -> ['^\s*def\s\+%s%s[=!]\?%s%s'] },
      \ 'headerFmt': { -> [s:ph] },
      \}

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""


let s:go = {
      \ 'parsers':   { -> ['^func\s\+%s%s%s%s\s*{'] },
      \ 'namePat':   { -> '\s*\%((.\{-})\s*\)\?\([^( \t]\+\)' },
      \ 'paramsPat': { -> '\s*(\(.\{-}\))' },
      \ 'rtypePat':  { -> '\s*\(.*\)\?' },
      \}

"{{{1
fun! s:go.headerFmt()
  let ln = getline(self.startLn)
  let f = match(ln, '^\s*func\s*(') >= 0
        \ ? '[' . matchstr(ln, '^\s*func\s*(.\{-}\s\+\zs.\{-}\ze)') . '] Method'
        \ : 'Function'
  let s = match(ln, '^\s*func\s*(') >= 0
        \ ? matchstr(ln, '^\s*func\s*(.\{-}\s\+\zs.\{-}\ze)') . '.'
        \ : ''
  return {
      \ 'boxed':    [f . ': %s' . s:ph, ''],
      \ 'nonboxed': [f . ': %s' . s:ph, ''],
      \ 'simple':   [s . '%s:' . s:ph],
      \ 'minimal':  [s . '%s:' . s:ph, ''],
      \}
endfun

fun! s:go.rtypeFmt() abort
  let rtype = substitute(self.parsed.rtype, '^(', '', '')
  let rtype = substitute(rtype, ')$', '', '')
  let rtype = empty(rtype) ? '' : '[' . trim(rtype) . ']'
  return [self.jollyChar() . 'return: ' . rtype . ' ' . s:ph]
endfun

fun! s:go.paramsNames() abort
  let params = substitute(self.parsed.params, '<.\{-}>', '', 'g')
  let params = substitute(params, '\s*=\s*[^,]\+', '', 'g')
  return map(split(params, ','), { k,v -> split(v)[0] })
endfun "}}}



"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Helpers
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

""
" the filetype-specific settings, if available
""
fun! s:FT()
  return get(s:, &filetype, {})
endfun

""
" s:docstring_words: return a pattern that matches docstring-specific words
""
fun! s:docstring_words(words) abort
  " {{{1
  " the word preceded by an optional jollyChar and followed by a space
  let wordPatterns = map(a:words, { k,v -> '.\?' . v . ' ' })
  " join word patterns and make them optional
  return '^\%(' . join(wordPatterns, '\|') . '\)\?\S\+:'
endfun "}}}

""
" s:align: align placeholders in the given line.
"
" @param lines: the lines to align
" @param ...:   an optional pattern, if found the line is kept as it is
" @return:      the aligned lines
""
fun! s:align(lines, ...) abort
  " {{{1
  let maxlen = max(map(copy(a:lines), { k,v -> strlen(a:0 && v =~ a:1 ? "" : v) }))
  if maxlen > 50 " don't align if lines are too long
    return a:lines
  endif
  for l in range(len(a:lines))
    if a:0 && a:lines[l] =~ '\V' . a:1
      continue
    elseif a:lines[l] =~ '\V' . s:ph
      let spaces = repeat(' ', maxlen - strlen(a:lines[l]))
      let a:lines[l] = substitute(a:lines[l], '\V' . s:ph, spaces . s:ph, '')
    endif
  endfor
  return a:lines
endfun "}}}

" vim: et sw=2 ts=2 sts=2 fdm=marker tags=tags
