""
" docgen#doc#new: start a new DocGen instance
" @return: the instance
""
fun! docgen#doc#new(is_docstring) abort
  "{{{1
  " b:docgen can create a new s:{&filetype} variable, to add support for
  " unsupported filetypes
  if exists('b:docgen')
    let s:{&filetype} = extend(s:FT(), b:docgen)
  endif

  let doc = extend(deepcopy(s:Doc), s:FT())
  let doc.style = docgen#style#get()
  let doc.style.is_docstring = a:is_docstring
  " so that s:Style can access the current instance
  let doc.style.doc = doc
  return doc
endfun "}}}



"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Docstring formatter initializer
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""
" The docstring is generated in several passages:
"
" 1. the parsers for the filetype are generated.
" 2. the parsers look for a potential target, if nothing is found the process
"     is aborted.
" 3. the style settings are evaluated, and raw (unformatted) templates for
"     lines are generated.
" 4. the target is parsed and a list of matches is the generated.
" 5. these matches are fed to the raw lines, that are formatted with printf()
"     using the matches as arguments.
"
" @member parsed:     parsed elements of the docstring (name, params, type, rtype)
"                     -> generated by doc.parse()
" @member templates:  unformatted templates for lines (header, params, rtype)
"                     -> generated by doc.templates()
" @member lines:      the formatted lines as they will be pasted in the buffer
"                     -> generated by doc.format()
""
let s:Doc = { 'parsed': {}, 'templates': {}, 'lines': {}, 'is_storage': 0 }


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Docstring formatter patterns
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" default patterns for function name, parameters, pre and post
let s:Doc.typePat   = { -> '\(\)' }
let s:Doc.namePat   = { -> '\s*\([^( \t]\+\)' }
let s:Doc.paramsPat = { -> '\s*(\(.\{-}\))' }
let s:Doc.rtypePat  = { -> '\s*\(.*\)\?' }

" default order for patterns, and the group they match in matchlist()
let s:Doc.order     = { -> ['type', 'name', 'params', 'rtype'] }

" default sections of the docstring
let s:Doc.sections  = { -> ['header', 'params', 'rtype'] }

" by default, no parsers for storage keywords
let s:Doc.storage      = { -> [] }
let s:Doc.storageLines = { -> [] }

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Docstring formatter styles
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let s:Doc.putBelow                 = { -> 0 }
let s:Doc.jollyChar                = { -> '@' }
let s:Doc.placeholder              = { -> '___' }
let s:Doc.leadingSpaceAfterComment = { -> 0 }

fun! s:Doc.frameChar()
  "{{{1
  return self.comment()[3]
endfun "}}}

""
" These functions fetch the format for the active style in doc.style.fmt[type]
" A default (minimal) formatter is returned if this fails for some reason.
""

fun! s:Doc.headerFmt()
  " {{{1
  return self.style.get_fmt('header')
endfun "}}}

fun! s:Doc.paramsFmt()
  " {{{1
  return self.style.get_fmt('params')
endfun "}}}

fun! s:Doc.rtypeFmt()
  " {{{1
  return self.style.get_fmt('rtype')
endfun "}}}

""
" Docstring is of box type.
""
fun! s:Doc.boxed()
  " {{{1
  return self.style.get_style() =~ 'box'
endfun "}}}

""
" Minimal docstring.
""
fun! s:Doc.minimal()
  " {{{1
  return self.style.get_style() == 'minimal'
endfun "}}}

""
" Docstring will be put below the declaration.
""
fun! s:Doc.below()
  " {{{1
  return get(s:FT(), '_putBelow', self.putBelow())
endfun "}}}




"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Docstring parser
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

""
" Function: s:Doc.parse
"
" Parse the target. If it's a function, parse its declaration and get its name,
" parameters and return type. If it's a storage type, it's handled elsewhere,
" just return the matching line.
"
" If it's a function, the parser creates a list of matches based on the
" different subpatterns. These subpatterns have a specific order, depending on
" the filetype. Once the list of matches is created, the groups must be
" assigned to the right variable in the right order, that is given by
" doc.order(). For example, if 'type' comes first in the order, parsed.type
" will be the variable that is assigned to the first matched group.
"
" Which variable will be assigned to which group, depends doc.order().
"
" @return: the line number with the function declaration
""
fun! s:Doc.parse() abort
  "{{{1
  let [self.startLn, self.endLn] = self.search_target()
  if !self.startLn
    return 0
  elseif self.is_storage
    return self.startLn
  endif
  let all  = matchlist(join(getline(self.startLn, self.endLn), "\n"), self.pattern)[1:]
  let ix = 0
  for group in self.order()
    let self.parsed[group] = substitute(trim(all[ix]), "\n", '', '')
    let ix += 1
  endfor
  return self.startLn
endfun "}}}


""
" Function: s:Doc.search_target
"
" Search the closest target upwards, if it can be found set the current pattern
" to the one that found it. When searching we don't move the cursor: we ensure
" that the match has a valid start and a valid end. The start must be on the
" same line or before it, the end can be after the current line. In both cases
" the searchs stops at empty lines, unless the search pattern includes '\n', in
" that case the search won't fail.
"
" @return: the line number with the docstring target
""
fun! s:Doc.search_target() abort
  "{{{1
  let [startLn, endLn] = [0, 0]

  let emptyLn = search('^\s*$', 'cnbW')
  let minLn = emptyLn ? '\%>' . emptyLn . 'l' : ''
  let emptyLn = search('^\s*$', 'cnW')
  let maxLn = emptyLn ? '\%<' . emptyLn . 'l' : ''
  let limit = minLn . maxLn

  for p in self.make_parsers()
    if !startLn || search(limit . p, 'cnbW') > startLn
      let startLn = search(limit . p, 'cnbW')
      let endLn = search(limit . p, 'cnbeW')
      if !endLn || endLn < startLn
        let endLn = search(limit . p, 'cneW')
      endif
      if !endLn
        let startLn = 0
      else
        let self.pattern = p
      endif
    endif
  endfor
  if !startLn
    let self.is_storage = 1
    for p in self.storage()
      if !startLn || search(limit . p, 'cnbW') > startLn
        let startLn = search(limit . p, 'cnbW')
        let endLn = search(limit . p, 'cnbeW')
        if !endLn || endLn < startLn
          let endLn = search(limit . p, 'cneW')
        endif
        if !endLn
          let startLn = 0
        else
          let self.pattern = p
        endif
      endif
    endfor
  endif
  return [startLn, endLn]
endfun "}}}


""
" Function: s:Doc.make_parsers
" Format the parsers with printf(), replacing the placeholders with the
" specific patterns for the current filetype.
"
" @return: the formatted parsers
""
fun! s:Doc.make_parsers() abort
  "{{{1
  let d = self
  let parsers = []
  let u_parsers = d.parsers()
  let pats = join(map(self.ordered_patterns(), { k,v -> string(v) }), ',')
  for p in range(len(u_parsers))
    let P = eval('printf(u_parsers[p],' . pats .')')
    call add(parsers, P)
  endfor
  return parsers
endfun "}}}


""
" Function: s:Doc.ordered_patterns
"
" @return: the patterns of the parser, in the order defined by the filetype
""
fun! s:Doc.ordered_patterns() abort
  "{{{1
  let s = self
  let o = self.order()
  return map(o, { k,v -> eval('s.'.o[k].'Pat()') })
endfun "}}}



"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Docstring templates
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

fun! s:Doc.make_templates() abort
  "{{{1
  let style = self.style.get_style()
  let ph = self.placeholder()
  for x in self.sections()
    let fmt = eval('self.'.x.'Fmt()')
    let self.templates[x] = type(fmt) == v:t_dict ? fmt[style] : fmt
    call map(self.templates[x], 'substitute(v:val, "%p", ph, "")')
  endfor
endfun "}}}



"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Docstring formatting
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

fun! s:Doc.format() abort
  "{{{1
  if self.is_storage
    let self.lines.header = self.storageLines()
  elseif self.minimal()
    let self.lines.params = []
    let self.lines.detail = []
    let self.lines.return = []
    let self.lines.header = filter(self.headerLines(), { k,v -> v != '' })
  else
    " process params and return first, if absent the docstring could be reduced
    let self.lines.params = s:align(self.paramsLines(), self.placeholder())
    let self.lines.detail = self.detailLines()
    let self.lines.return = self.retLines()
    let self.lines.header = self.headerLines()
  endif
endfun "}}}

""
" Function: s:Doc.headerLines
"
" @return: the line(s) with the formatted description
""
fun! s:Doc.headerLines() abort
  "{{{1
  let header = self.templates.header

  " some text that doesn't contain %s placeholders, return it as it is
  let linesWithName = filter(copy(header), 'v:val =~ "%s"')
  if empty(linesWithName)
    return header
  endif

  " remove empty lines if no params nor return statement
  if empty(self.lines.params) && empty(self.lines.return)
    call filter(header, { k,v -> v != '' })
  endif

  return map(header, { k,v -> v =~ '%s' ? printf(v, self.parsed.name) : v })
endfun "}}}


""
" Function: s:Doc.paramsNames
" Parse the parameters string, remove unwanted parts, and return a list with
" the parameters names.
"
" @return: a list with the parameters names
""
fun! s:Doc.paramsNames() abort
  "{{{1
  if !has_key(self.parsed, 'params')
    return []
  endif
  let params = substitute(self.parsed.params, '<.\{-}>', '', 'g')
  let params = substitute(params, '\s*=\s*[^,]\+', '', 'g')
  return split(params, ',')
endfun "}}}


""
" Function: s:Doc.paramsLines
"
" @return: the formatted line(s) with parameters
""
fun! s:Doc.paramsLines() abort
  "{{{1
  let lines = []
  for param in self.paramsNames()
    for line in self.templates.params
      call add(lines, line =~ '%s' ? printf(line, trim(param)) : line)
    endfor
  endfor
  return lines
endfun "}}}


""
" Function: s:Doc.detailLines
" Additional lines for more detailed description. Empty by default.
"
" @return: the formatted line(s) with the placeholder.
""
fun! s:Doc.detailLines() abort
  "{{{1
  return []
endfun "}}}

""
" Function: s:Doc.retLines
" By default there's no text replacement in the return line, so the template is
" returned as it it.
"
" @return: the formatted line(s) with the return value
""
fun! s:Doc.retLines() abort
  "{{{1
  return self.templates.rtype
endfun "}}}


""
" Function: s:Doc.comment
"
" @return: a list with four elements:
"          [0]  the opening multiline comment chars
"          [1]  the chars for lines in between
"          [2]  the closing multiline comment chars
"          [3]  a single char used for box frame
""
fun! s:Doc.comment()
  " {{{1
  let cs = empty(&commentstring) ? '/*%s*/' : &commentstring
  let cm = cs =~ '//\s*%s' ? '/*%s*/' : cs
  let c = substitute(split(cs, '%s')[0], '\s*$', '', '')
  return cm == '/*%s*/' ? ['/**', ' *', ' */', '*'] : [c, c, c, '-']
endfun "}}}


let s:Doc.preserve_oldlines = function('docgen#preserve#lines')


""
" Function: s:Doc.previous_docstring
"
" @param start: start line
" @param below: whether the docstring will be added below the declaration
" @return: the lines in the docstring before update
""
fun! s:Doc.previous_docstring(start, below) abort
  " {{{1
  let lines = []
  let start = a:start
  if !a:below
    while 1
      if start == 1
        break
      elseif self.is_comment(start - 1)
        call add(lines, getline(start - 1))
        exe (start - 1) . 'd _'
        let start -= 1
      else
        break
      endif
    endwhile
  else
    while 1
      if start == line('$')
        break
      elseif self.is_comment(start + 1)
        call add(lines, getline(start + 1))
        exe (start + 1) . 'd _'
        let start += 1
      else
        break
      endif
    endwhile
  endif
  if !empty(lines)
    let c = self.comment()
    while trim(lines[0]) !~ '\k'
      call remove(lines, 0)
    endwhile
    while trim(lines[-1]) !~ '\k'
      call remove(lines, -1)
    endwhile
    for ix in range(len(lines))
      if lines[ix] !~ '\k'
        let lines[ix] = ''
      else
        try
          let lines[ix] = substitute(lines[ix], '^\V\s\*' . c[1] . '\+\s\?', '', '')
          let lines[ix] = substitute(lines[ix], '\V\s\+' . c[1] . '\_$', '', '')
        catch /.*/
        endtry
      endif
    endfor
  endif
  return reverse(lines)
endfun "}}}


""
" Function: s:Doc.create_box
" Create a box with the docstring
"
" @param lines: the docstring lines
" @param boxed: with full frame or not
" @param rchar: character used for full frame
" @param extraHeight: additional empty lines near the edges
" @return: the box lines
""
fun! s:Doc.create_box(lines) abort
  " {{{1
  let [a, m, b, _] = self.comment()[:3]
  let rwidth = &tw ? &tw : 79
  let char = self.frameChar()
  if self.boxed() && a == '/**'
    let box1 = a . repeat(char, rwidth - strlen(a))
    let box2 = ' ' . repeat(char, rwidth - strlen(b)) . trim(b)
  elseif self.boxed()
    if !self.style.is_docstring && self.leadingSpaceAfterComment()
      let [a, b] = [a . ' ', b . ' ']
    endif
    let box1 = a . repeat(char, rwidth - strlen(a))
    let box2 = b . repeat(char, rwidth - strlen(b))
  else
    let box1 = a
    let box2 = b
  endif
  let extra = map(range(self.style.extraHeight), { k,v -> m })
  let post = self.style.is_docstring ? self.comment()[4:] : []
  ""
  " Reformat the lines as comment. Top and bottom lines are not handled here.
  "   - empty line ? comment char(s)
  "   - no comment char(s) (eg. python docstrings)? just the line
  "   - both? concatenate comment chars and line, with a space in between
  ""
  call map(a:lines, 'v:val == "" ? m : m == "" ? v:val : (m . " " . v:val)')
  return [box1] + extra + a:lines + extra + [box2] + post
endfun "}}}


""
" Function: s:Doc.reindent_box
"
" @param lines: the lines to reindent
""
fun! s:Doc.reindent_box(lines) abort
  "{{{1
  silent keepjumps normal! `[=`]
  let ind = matchstr(getline('.'), '^\s*')
  let lines = map(a:lines, "substitute(v:val, '^\s*', ind, '')")
  let [first, i, char] = [line('.') + 1, line('.'), self.frameChar()]
  let maxw = (&tw ? &tw : 79) - strdisplaywidth(ind) + strlen(ind)
  " executing DocBox on a previous comment and wanting a full box
  let is_boxifying_comment = !self.style.is_docstring &&
        \                     self.was_comment && self.style.fullbox

  for line in lines
    if strlen(line) > maxw
      let removeChars = printf('\V%s\{%s}', char, strlen(line) - maxw)
      let line = substitute(line, removeChars, '', '')
    endif
    if is_boxifying_comment && strlen(line) < maxw
      let line .= repeat(' ', maxw - strdisplaywidth(line) - strwidth(char)) . char
      if self.style.centered && i == first
        let cchar = trim(self.comment()[1])
        let ind = matchstr(line, '^\s*')
        let text = trim(matchstr(line, '^\V\s\*' . cchar . '\zs\.\*\ze' . char))
        let spaces = maxw - strlen(ind) - strdisplaywidth(text) - strwidth(char) - strwidth(cchar)
        let s = repeat(' ', spaces/2)
        let [s1, s2] = spaces % 2 ? [s, s . ' '] : [s, s]
        let line = ind . cchar . s1 . text . s2 . char
      endif
    endif
    call setline(i, line)
    let i += 1
  endfor
endfun "}}}


""
" Function: s:Doc.is_comment
"
" @param line: the line to evaluate
" @return: if the evaluated line is a comment (or a docstring)
""
fun! s:Doc.is_comment(line) abort
  "{{{1
  return synIDattr(synID(a:line, match(a:line, '\S') + 1, 1), "name") =~? 'comment'
endfun "}}}


""
" Function: s:Doc.replace_comment
" Replace previous docstring with the new one.
"
" @return: the removed lines, if not empty
""
fun! s:Doc.replace_comment() abort
  "{{{1
  let startLn = 0
  if self.is_comment(line('.'))
    let [startLn, endLn] = [line('.'), line('.')]
    while self.is_comment(startLn - 1)
      let startLn -= 1
    endwhile
    while self.is_comment(endLn + 1)
      let endLn += 1
    endwhile
    let lines = getline(startLn, endLn)
    " strip the previous comment chars
    call map(lines, { k,v -> substitute(v, '^\s*[[:punct:]]\+\%(\s*\_$\|\s\)', '', '') })
    if empty(lines[0])
      call remove(lines, 0)
    endif
    if empty(lines[-1])
      call remove(lines, -1)
    endif
    exe startLn . ',' . endLn . 'd _'
  else
    let lines = ['']
  endif
  return lines
endfun "}}}



"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Filetype-specific
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

""
" Each filetype will define at least a list of function parsers.
" After that, each can provide specific members or methods.
""

let s:vim    = docgen#ft#vim#get()
let s:c      = docgen#ft#c#get('c')
let s:cpp    = docgen#ft#c#get('cpp')
let s:python = docgen#ft#python#get()
let s:lua    = docgen#ft#lua#get()
let s:sh     = docgen#ft#sh#get()
let s:java   = docgen#ft#java#get()
let s:ruby   = docgen#ft#ruby#get()
let s:go     = docgen#ft#go#get()


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Helpers
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

""
" The filetype-specific settings, if available.
""
fun! docgen#doc#ft()
  "{{{1
  return get(s:, &filetype, {})
endfun

let s:FT = function('docgen#doc#ft')
 "}}}

""
" s:align: align placeholders in the given line.
"
" @param lines: the lines to align
" @param ...:   an optional pattern, if found the line is kept as it is
" @return:      the aligned lines
""
fun! s:align(lines, ph, ...) abort
  " {{{1
  let maxlen = max(map(copy(a:lines), { k,v -> strlen(a:0 && v =~ a:1 ? "" : v) }))
  if maxlen > 50 " don't align if lines are too long
    return a:lines
  endif
  for l in range(len(a:lines))
    if a:0 && a:lines[l] =~ '\V' . a:1
      continue
    elseif a:lines[l] =~ '\V' . a:ph
      let spaces = repeat(' ', maxlen - strlen(a:lines[l]))
      let a:lines[l] = substitute(a:lines[l], '\V' . a:ph, spaces . a:ph, '')
    endif
  endfor
  return a:lines
endfun "}}}

" vim: et sw=2 ts=2 sts=2 fdm=marker tags=tags
